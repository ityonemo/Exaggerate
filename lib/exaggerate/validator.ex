defmodule Exaggerate.Validator do

  defstruct methods: []

  @type t :: %__MODULE__{methods: [Macro.t]}

  alias Exaggerate, as: E
  alias Exaggerate.AST
  alias Exaggerate.Tools

  @spec route(E.route, E.spec_map) :: Macro.t
  def route({_path, _verb}, spec = %{"operationId" => id}) do
    parsed = %__MODULE__{}
    |> build_body(id, spec)
    |> build_param(id, spec)
    |> build_response(id, spec)

    AST.splice_blocks(parsed.methods)
  end

  @spec build_body(t, String.t, E.spec_map) :: t
  def build_body(parser, id, %{"requestBody" => %{"content" => cmap}}) do
    parserlist = cmap
    |> Enum.with_index
    |> Enum.map(fn
      {{mimetype, %{"schema" => smap}}, idx} ->
        generate_body_block(id <> "_content_" <> inspect(idx), smap, mimetype)
      _ -> nil
    end)
    |> Enum.filter(&(&1))

    %__MODULE__{parser | methods: parser.methods ++ parserlist}
  end
  def build_body(parser, _, _), do: parser

  @spec build_param(t, String.t, E.spec_map) :: t
  def build_param(parser, id, %{"parameters" => pmap}) do
    parserlist = pmap
    |> Enum.with_index
    |> Enum.map(fn {def = %{"schema" => smap}, idx} ->
        generate_parameter_block(id <> "_parameters_" <> inspect(idx),
          smap, def["required"])
      _ -> nil
    end)
    |> Enum.filter(&(&1))

    %__MODULE__{parser | methods: parser.methods ++ parserlist}
  end
  def build_param(parser, _, _), do: parser

  @spec build_response(t, String.t, E.spec_map) :: t
  def build_response(parser, id, %{"responses" => rmap}) do
    case Exaggerate.Validator.Response.block(id, rmap) do
      block ->
        %__MODULE__{parser | methods: parser.methods ++ [block]}
      nil ->
        parser
    end
  end
  def build_response(parser, _, _), do: parser

  @spec generate_body_block(String.t, E.spec_map, String.t) :: Macro.t
  def generate_body_block(label, spec, mimetype) do
    label_atom = String.to_atom(label)
    spec_str = spec
    |> Jason.encode!(pretty: true)
    |> AST.ensigil

    schema = {:defschema, [], [[{label_atom, spec_str}]]}

    quote do
      @spec unquote(label_atom)(Exonerate.json, String.t, String.t) :: :ok | Exaggerate.error
      def unquote(label_atom)(content, unquote(mimetype), unquote(mimetype)) do
        unquote(label_atom)(content)
      end
      def unquote(label_atom)(_, _, _) do
        :ok
      end
      unquote(schema)
    end
  end

  @spec generate_parameter_block(String.t, E.spec_map, boolean) :: Macro.t
  @doc """
  generates a validation block for a particular test, based on the
  `parameter` archetype.  This is a trampoline, if it's optional,
  followed by a defschema statement (pulling from exonerate).
  """
  def generate_parameter_block(label, spec, required) do
    label_atom = String.to_atom(label)
    spec_str = spec
    |> Jason.encode!(pretty: true)
    |> AST.ensigil

    schema = {:defschema, [], [[{label_atom, spec_str}]]}

    if required do
      schema
    else
      trampoline = String.to_atom(label <> "_trampoline")
      quote do
        @spec unquote(trampoline)(Exonerate.json) :: :ok | Exaggerate.error
        def unquote(trampoline)(content) do
          if is_nil(content) do
            :ok
          else
            unquote(label_atom)(content)
          end
        end
        unquote(schema)
      end
    end
  end

  @spec module(atom, E.spec_map) :: Macro.t
  def module(moduleroot, spec), do: module(moduleroot, spec, "test.json")

  @spec module(atom, E.spec_map, String.t) :: Macro.t
  def module(moduleroot, spec, filename) do

    validations = spec
    |> Map.get("paths")
    |> Enum.flat_map(&Tools.unpack_route(&1, Exaggerate.Validator))

    validator = Module.concat(moduleroot, :Validator)

    if validations == [{:__block__, [], [nil]}] do
      quote do
        defmodule unquote(validator) do
          @moduledoc false

          @comment ""
          @comment "      --WARNING--"
          @comment ""
          @comment unquote("currently, your swaggerspec `#{filename}` does not contain any")
          @comment "input or output JSON validations.  However, please keep this"
          @comment "module in this location as a placeholder in case a future update of"
          @comment unquote("`#{filename}` should require it.")
          @comment ""
          @comment ""
        end
      end
    else
      quote do
        defmodule unquote(validator) do
          @moduledoc false

          @comment ""
          @comment "      --WARNING--"
          @comment ""
          @comment "all code in this file is autogenerated.  Alterations to this code risk"
          @comment "introducing deviations to the supplied OpenAPI specification. Please"
          @comment unquote("consider modifying `#{filename}` instead of this file, followed by")
          @comment ""
          @comment unquote("    `mix swagger.update #{filename}`")
          @comment ""
          @comment ""

          @blankline _

          import Exonerate

          unquote_splicing(validations)
        end
      end
    end
  end


  @doc """
  generates a validation module as a submodule of the current module.

      defmodule Module do
        validator my_scheme: ~s(<json-string>)
      end

  creates the following module:

      defmodule Module.MySchemeWeb.Validator do
        ...
        <validation code>
        ...
      end

  Mostly useful for testing.  Note that the main module does NOT use this function
  but calls module() instead.
  """
  defmacro validator(modulename, spec_json) do
    # takes some swagger text and expands it so that the current
    # module is a desired router.

    validations = spec_json
    |> Macro.expand(__CALLER__)
    |> Jason.decode!

    __CALLER__.module
    |> Module.concat(Macro.camelize(modulename <> "_web"))
    |> module(validations)
    |> AST.decomment
  end

end
