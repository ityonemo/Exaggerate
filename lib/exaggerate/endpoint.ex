defmodule Exaggerate.Endpoint do

  defstruct params: [],
            status: false,
            type: false

  @type t::%__MODULE__{
    params: [atom],
    status: boolean,
    type: boolean
  }

  alias Exaggerate.AST
  alias Exaggerate.Tools

  @type endpointmap :: %{required(atom) => list(atom)}

  @spec module(atom | binary, E.spec_map) :: Macro.t
  def module(moduleroot, spec), do: module(moduleroot, spec, "test.json")

  @spec module(atom | binary, E.spec_map, String.t) :: Macro.t
  def module(moduleroot, spec, filename) do
    endpoint = Module.concat(moduleroot, :Endpoint)

    # generate the endpoint struct.
    ep_map = ep_struct_from_spec(spec)

    module_from_ep_map(endpoint, ep_map, filename)
  end

  defp ep_struct_from_spec(%{"paths" => paths}) do
    paths
    |> Enum.flat_map(&ep_struct_from_path/1)
    |> Enum.into(%{})
  end
  defp ep_struct_from_path({_, routes}) do
    Enum.map(routes, &ep_struct_from_route/1)
  end
  defp ep_struct_from_route({_, routemap = %{"operationId" => oid}}) do
    params = ep_params(routemap)
    {
      String.to_atom(oid),
      %__MODULE__{params: params}
    }
  end

  def ep_params(routemap) do
    #
    # this function is super-ugly.  It can be fixed.
    #
    if routemap["parameters"] do
      routemap
      |> Map.get("parameters")
      |> Enum.map(fn
        %{"name" => name, "required" => true} -> String.to_atom(name)
        _ -> nil
      end)
      |> Enum.filter(&(&1))
    else
      []
    end ++ if routemap["requestBody"] do
      [:content]
    else
      []
    end
  end

  @doc """
  generates a skeleton endpoint module from an module name (string) and an
  endpoint map, which is a map structure representing atoms matched with a
  list of parameters to be passed into the map.

  Typically, the module name will derive from the basename of the json file
  from which the swagger template comes.  In general, this function will be
  called by `mix swagger` but not `mix swagger update`, which will parse out
  the existing functions first.
  """
  @spec module_from_ep_map(String.t, endpointmap, Path.t) :: Macro.t
  def module_from_ep_map(module, endpoints, filename) do
    code = Enum.map(endpoints, &block/1)

    quote do
      @comment ""
      @comment unquote("NB. this file is autogenerated from `#{filename}`, altering")
      @comment "the structure or arrangement of the methods in this file can"
      @comment "cause problems."
      @comment ""

      @blankline _

      defmodule unquote(module) do
        unquote_splicing(code)
      end
    end
  end

  @doc """
  generates a skeleton endpoint block from an endpoint name (atom) and a
  list of matched variables.

  This block is intended to be filled out by the user.  @comment values
  are going to be swapped out, later in AST processing, for # comments.
  """
  @spec block({atom, t}) :: Macro.t
  def block({ep, v}), do: block(ep, v)

  @spec block(atom, t) :: Macro.t
  def block(endpoint, %__MODULE__{params: vars}) do
    raise_str = "error: #{endpoint} not implemented"
    mvars = Enum.map(vars, fn var -> {var, [], Elixir} end)
    quote do
      def unquote(endpoint)(_conn, unquote_splicing(mvars)) do
        @comment "autogen function."
        @comment "insert your code here, then delete"
        @comment "the next exception:"

        raise unquote(raise_str)
      end
    end
  end

  @doc """
  analyzes an existing module document and retrieves a list of implemented
  endpoints.
  """
  @spec list_endpoints(binary) :: [atom]
  def list_endpoints(modulecode) when is_binary(modulecode) do
    modulecode
    |> Code.format_string!
    |> list_endpoints_io
  end

  @spec list_endpoints_io(iodata) :: [atom]
  def list_endpoints_io(["def", " ", endpoint | rest]) do
    [String.to_atom(endpoint) | list_endpoints_io(rest)]
  end
  def list_endpoints_io([]), do: []
  def list_endpoints_io([_ | rest]), do: list_endpoints_io(rest)

  @doc """
  pulls an existing file which contains an endpoint module and retrieves a
  list of implemented endpoints.
  """
  @spec list_file_endpoints(Path.t) :: [atom]
  def list_file_endpoints(filepath) do
    filepath
    |> Path.expand
    |> File.read!
    |> list_endpoints
  end

  defp insert_routes(content, new_routes) do
    lines = String.split(content, "\n")

    last_end_idx = lines
    |> Enum.with_index
    |> Enum.filter(fn {str, _} -> String.contains?(str, "end") end)
    |> Enum.map(fn {_, idx} -> idx end)
    |> Enum.max

    lines
    |> Enum.slice(0..(last_end_idx - 1))
    |> Enum.concat(new_routes)
    |> Enum.concat(["end\n"])
    |> Enum.join("\n")
    |> Code.format_string!
  end

  @spec update(Path.t, map) :: :ok | {:error, any}
  def update(filepath, routespec) do
    existing_routes = list_file_endpoints(filepath)

    new_routes = routespec
    |> Enum.reject(fn {k, _} -> k in existing_routes end)
    |> Enum.map(&block/1)
    |> Enum.map(&AST.to_string/1)

    updated_content = filepath
    |> File.read!
    |> insert_routes(new_routes)
    |> Enum.concat(["\n"])

    File.write!(filepath, updated_content)
  end

end
